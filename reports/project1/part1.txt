Part I: Odometry

Algorithm:

	In order to accomplish the first project, we decided to build our own framework that was multi-threaded. We used the MiGIO code as a reference, but the only part that was kept the same were the serial interface calls to the Pleo. The framework was built around the concept of sub-systems, with a sub-system for the pleo, the camera, and a planner. Each sub-system runs in its own thread, has its own log file and can communicate with the other sub-systems through a shared queue. This allowed us to separate the work for project 1 very well, and we believe it will also provide us a head start into the further projects in the class. The sub-systems are started from the main entry point in the program from an interactive command prompt it provides. The user can start specific sub-systems or all of them. Users can also issue commands to the sub-systems to control their behavior. For example, we have a 'walkForward' command in the Pleo sub-system that the user can initiate directly from the interactive prompt. The architecture of the system can be seen in the following diagram:



	The Pleo sub-system handles all the communications and behaviors of the Pleo. We used the existing serial functions provided by MiGIO to communicate with the Pleo for sending joint commands and for retrieving sensor values. We first implemented basic movement in this sub-system with commands like 'liftHead' and 'lowerTail'. These commands simply provide for a specific set of joint values that are sent to the Pleo. We also implemented a movement sequencer so that we could create more complex movements like walking and turning. These sequences are just an array of joint angles that we send to the Pleo over time. There is a delay between each send when we are sequencing, and we have the option of repeating the sequence over and over if necessary. For many of the sequences, we added a cycles parameter instead, so we can instruct the Pleo to perform the walkForward movement sequence a particular number of times. This was key in allowing Pleo to move a fixed distance.

	The Camera sub-system implements the OpenCV code that captures images from the camera and displays Pleo's current position and path. It will be described in Part II.


	The Planner sub-system is the area of the code that determines the overall behavior for the other sub-systems. For this project, we implemented two planner behaviors: performSquare and performTriangle. These behaviors will instruct the Pleo and Camera sub-systems to perform their behaviors to implement the overall desired result. For example, the planner is the one who decides how far Pleo will walk forward, and when to turn. In the future, we believe that the planner sub-system will grow more complex as it interprets more input from the camera and instructs Pleo in a more dynamic way.

	For the perform square part of the project, we used observation and trial and error to get pleo to walk approximately 1m and turn 90 degrees. We used this observation to instruct the planner on exactly how many cycles of the walkForward and turnRight commands to issue to the Pleo. Because we are using dead reckoning for this project, we didn't incorporate any adjustments from the camera data into the commands to the Pleo. Unfortunately due to variables that are out of our control such as friction on the carpet and drag of the USB cable, these movements aren't very precise.

	Square run : 








Questions:

1. For each segment of your path, what is the difference between the target displacement and the one you achieved? Repeat the experiment at least 3 times and report averages.

2. When the trajectory completes, how far is the robot from its initial position and orientation?

** Do 3 squares. Turn down the capture rate so we have fewer dots on the path. Capture 3 screenshots, calculate average displacements. (tim/shashank)

3. What are the reasons for this error? Discuss the assumptions you made about how the robot functions and list any possible causes that it does not do exactly what you expect.

- We first assumed Pleo was symetric (with regard to measurements and weight distribution) along the X axis, but we found this wasn't completely true – his left hind leg knee was not quite as accurate as the right hind leg knee, often undershooting the desired angle, and we had to compensate for this.

- When moving two joints on the same limb, the order that they changed wasn't consistent, so our final movement was impacted.
- Surface impacted performance of the walk, even in different parts of the carpet.
- His feet can get caught on the carpet and this throws off the gait and direction.
- Querying data on the serial port too fast seems to cause it to slow down when sending joint commands.
- Age of pleo - noticed eratic behavior of some joints, where they would not extend fully, or would report themselves normalized when they were still obviously offset.


